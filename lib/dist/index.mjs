var W=Object.defineProperty,Y=Object.defineProperties;var z=Object.getOwnPropertyDescriptors;var G=Object.getOwnPropertySymbols;var V=Object.prototype.hasOwnProperty,X=Object.prototype.propertyIsEnumerable;var F=(p,e,t)=>e in p?W(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t,v=(p,e)=>{for(var t in e||(e={}))V.call(e,t)&&F(p,t,e[t]);if(G)for(var t of G(e))X.call(e,t)&&F(p,t,e[t]);return p},R=(p,e)=>Y(p,z(e));var l=(p,e,t)=>new Promise((o,n)=>{var s=d=>{try{a(t.next(d))}catch(c){n(c)}},i=d=>{try{a(t.throw(d))}catch(c){n(c)}},a=d=>d.done?o(d.value):Promise.resolve(d.value).then(s,i);a((t=t.apply(p,e)).next())});import{createWriteStream as Z,mkdirSync as ee}from"fs";import{join as Q}from"path";import{format as w}from"util";var _={reset:"\x1B[0m",info:"\x1B[32m",warn:"\x1B[93m",error:"\x1B[31m",header:"\x1B[36m",debug:"\x1B[90m",event:"\x1B[35m",special:"\x1B[37m"},r=class{static configure(e){this.config=v(v({},this.config),e)}static formatMessage(e,t){let o=new Date,n=o.getFullYear(),s=String(o.getMonth()+1).padStart(2,"0"),i=String(o.getDate()).padStart(2,"0"),a=String(o.getHours()).padStart(2,"0"),d=String(o.getMinutes()).padStart(2,"0"),c=String(o.getSeconds()).padStart(2,"0"),g=`${n}-${s}-${i}:${a}.${d}.${c}`;return e==="special"?`${_.reset}${_.special}${g} [${e.toUpperCase()}]: \x1B[31m[${t}\x1B[31m]${_.reset}
`:`${_.reset}${_[e]}${g} [${e.toUpperCase()}]: ${t}${_.reset}
`}static log(e,t){let o=new Date().toISOString(),n=this.formatMessage(e,t);this.noPrint||process.stdout.write(n),this.config.preserveLogs&&this.config.externalCallback&&this.config.externalCallback(e,t,o)}static special(e){let t=typeof e=="string"?e:w(e);this.log("special",t)}static event(e){let t=typeof e=="string"?e:w(e);this.log("event",t)}static debug(e){let t=typeof e=="string"?e:w(e);this.log("debug",t)}static info(e){let t=typeof e=="string"?e:w(e);this.log("info",t)}static warn(e){let t=typeof e=="string"?e:w(e);this.log("warn",t)}static error(e){let t=typeof e=="string"?e:w(e);this.log("error",t)}static header(e){let t=typeof e=="string"?e:w(e);this.log("header",t)}};r.noPrint=!1,r.config={preserveLogs:!1};var J=Q(process.cwd(),"logs"),q,te=()=>`dpcp-${new Date().toISOString().replace(/[:.]/g,"-")}.log`,oe=()=>{try{ee(J,{recursive:!0});let p=Q(J,te());return q=Z(p,{flags:"a"}),!0}catch(p){return process.stderr.write(`Failed to create log directory: ${p}
`),!1}},re=(p,e,t)=>{if(!q&&!oe())return;let o=`${t} [LOGGER][${p.toUpperCase()}]: ${e}
`;q.write(o)};r.configure({preserveLogs:!0,externalCallback:re});var N;(i=>(i.SERVICE_CALLBACK=a=>{r.warn("REMOTE_SERVICE_CALLBACK not set")},i.SETUP_CALLBACK=a=>l(void 0,null,function*(){r.warn("SETUP_CALLBACK not set")}),i.PRE_CALLBACK=a=>l(void 0,null,function*(){r.warn("PRE_CALLBACK not set")}),i.REPORTING_CALLBACK=a=>l(void 0,null,function*(){r.warn("REPORTING_CALLBACK not set")}),i.BROADCAST_REPORTING_CALLBACK=a=>l(void 0,null,function*(){r.warn("BROADCAST_REPORTING_CALLBACK not set")}),i.NODE_STATUS_CALLBACK=a=>l(void 0,null,function*(){r.warn("NODE_STATUS_CALLBACK not set")})))(N||(N={}));var E;(t=>(t.LOCAL="local",t.REMOTE="remote"))(E||(E={}));var T;(t=>(t.RAW="raw",t.COMPRESSED="compressed"))(T||(T={}));var x;(o=>(o.DEFAULT=1,o.PERSISTANT=2,o.AUTO_DELETE=4))(x||(x={}));var S;(h=>(h.CHAIN_NOTIFIED="chain_notified",h.CHAIN_DEPLOYED="chain_deployed",h.CHAIN_SETUP_COMPLETED="chain_setup_completed",h.NODE_PENDING="node_pending",h.NODE_IN_PROGRESS="node_in_progress",h.NODE_COMPLETED="node_completed",h.NODE_FAILED="node_failed",h.NODE_SETUP_COMPLETED="node_setup_completed",h.CHILD_CHAIN_STARTED="child_chain_started",h.CHILD_CHAIN_COMPLETED="child_chain_completed",h.NODE_PENDING_DELETION="node_pending_deletion",h.NODE_END_OF_PIPELINE="node_end_of_pipeline",h.NODE_SUSPENDED="node_suspended",h.NODE_RESUMED="node_resumed"))(S||(S={}));var f;(h=>(h.NODE_SETUP="node_setup",h.NODE_CREATE="node_create",h.NODE_DELETE="node_delete",h.NODE_RUN="node_run",h.NODE_SEND_DATA="node_send_data",h.NODE_ERROR="node_error",h.NODE_RESUME="node_resume",h.NODE_STOP="node_stop",h.NODE_SUSPEND="node_suspend",h.NODE_PRE="node_pre",h.CHAIN_PREPARE="chain_prepare",h.CHAIN_START="chain_start",h.CHAIN_START_PENDING_OCCURRENCE="chain_start_pending_occurrence",h.CHAIN_DEPLOY="chain_deploy"))(f||(f={}));import{setImmediate as ae}from"timers";import{randomUUID as se}from"node:crypto";import ne from"node:events";import{randomUUID as ie}from"node:crypto";var D=class extends ne{constructor(){super(),this.uid=ie()}};var k=class k extends D{constructor(){super();this.status=[];if(!(k.authorizedAgent instanceof D))throw new Error("Node Reporter needs to be instantiated by an authorized Agent");k.authorizedAgent=null}static authorize(t){k.authorizedAgent=t}notify(t,o="local-signal"){let{status:n}=t;r.info(`Status ${n} from ${this.uid}`),this.status.push(n),this.emit(o,t)}getSignals(){return this.status}};k.authorizedAgent=null;var I=k;var O=class extends I{constructor(t,o){super();this.chainId=t;this.nodeId=o}},P=class p extends D{constructor(){super(),this.workflow={},this.remoteMonitoringHost=new Map,this.reportingCallback=N.REPORTING_CALLBACK,this.broadcastReportingCallback=N.BROADCAST_REPORTING_CALLBACK}getWorkflow(){return this.workflow}static retrieveService(e=!1){if(!p.instance||e){let t=new p;p.instance=t}return p.instance}setReportingCallback(e){this.reportingCallback=e}setBroadcastReportingCallback(e){this.broadcastReportingCallback=e}getRemoteMonitoringHost(e){return this.remoteMonitoringHost.get(e)}setRemoteMonitoringHost(e,t){this.remoteMonitoringHost.set(e,t)}genReportingAgent(e){let{chainId:t,nodeId:o,index:n}=e;O.authorize(this);let s=new O(t,o);return s.on("global-signal",i=>l(this,null,function*(){r.event(`Receive global-signal:
				${JSON.stringify(i)}
				for node ${o}
`);let a=R(v({},e),{signal:i});n>0?(i.broadcasted=!0,this.broadcastReportingCallback(a)):yield this.reportingCallback(a)})),s.on("local-signal",i=>l(this,null,function*(){r.event(`Receive local-signal:
				${JSON.stringify(i)}
				for node ${o} in chain ${t}
`);let a=R(v({},e),{signal:i}),d={[a.nodeId]:{[a.signal.status]:!0}};this.workflow[a.chainId]||(this.workflow[a.chainId]={});let c=this.workflow[a.chainId].status||{},g=v(v({},c),d);this.workflow[a.chainId].status=g,o==="supervisor"&&(yield this.reportingCallback(a))})),s}getChainStatus(e){var t;return(t=this.workflow[e])==null?void 0:t.status}setChainSetupCount(e,t){this.workflow[e]||(this.workflow[e]={}),this.workflow[e].setupCount=t}getChainSetupCount(e){var t;return(t=this.workflow[e])==null?void 0:t.setupCount}setChainDeployed(e){this.workflow[e]||(this.workflow[e]={}),this.workflow[e].deployed=!0}getChainDeployed(e){var t;return(t=this.workflow[e])==null?void 0:t.deployed}setChainSetupCompleted(e){this.workflow[e]||(this.workflow[e]={}),this.workflow[e].setupCompleted=!0}getChainSetupCompleted(e){var t;return(t=this.workflow[e])==null?void 0:t.setupCompleted}};var A=class{constructor(e){this.node=e;this.signalQueue=[];this.currentCursor=0;this.status=[];this.suspendedState=null}handleStopSignal(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing STOP signal")})}handleSuspendSignal(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing Suspend signal"),this.status.includes(S.NODE_SUSPENDED)||(this.status.push(S.NODE_SUSPENDED),r.info(`Node ${this.node.getId()} suspended.`))})}handleResumeSignal(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing RESUME signal");let e=this.status.indexOf(S.NODE_SUSPENDED);if(e>-1){if(this.status.splice(e,1),!this.suspendedState){r.warn(`~ NodeStatusManager: Node ${this.node.getId()} may have resumed prematurely.`);return}return r.info(`~ NodeStatusManager: Resuming node ${this.node.getId()}...`),this.node.execute(this.suspendedState.data)}else r.warn(`~ NodeStatusManager: Cannot resume Node ${this.node.getId()}, not in suspended state.`)})}suspendExecution(e,t,o){this.suspendedState={generator:e,currentBatch:t,data:o}}getSuspendedState(){return this.suspendedState}clearSuspendedState(){this.suspendedState=null}isSuspended(){return this.status.includes(S.NODE_SUSPENDED)}handleErrorSignal(){return l(this,null,function*(){r.error("NodeStatusManager: Processing ERROR signal")})}handleNodeSetup(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing NODE_SETUP signal")})}handleNodeCreate(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing NODE_CREATE signal")})}handleNodeDelete(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing NODE_DELETE signal")})}handleNodeRun(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing NODE_RUN signal")})}handleNodeSendData(){return l(this,null,function*(){r.info("~ NodeStatusManager: Processing NODE_SEND_DATA signal")})}updateQueue(e){this.signalQueue=e,this.currentCursor=0}enqueueSignals(e,t){return l(this,null,function*(){var o;this.signalQueue.push(...e),t&&((o=this.suspendedState)!=null&&o.data)&&(this.suspendedState.data=t.data),t!=null&&t.params&&this.suspendedState&&(this.suspendedState.previousNodeParams=t.params),e.length>0&&e[0]===f.NODE_RESUME&&(yield this.process())})}processNextSignal(){return l(this,null,function*(){try{let e=this.signalQueue[this.currentCursor];switch(e){case f.NODE_STOP:return this.handleStopSignal();case f.NODE_SUSPEND:return this.handleSuspendSignal();case f.NODE_RESUME:return this.handleResumeSignal();case f.NODE_ERROR:return this.handleErrorSignal();case f.NODE_SETUP:return this.handleNodeSetup();case f.NODE_CREATE:return this.handleNodeCreate();case f.NODE_DELETE:return this.handleNodeDelete();case f.NODE_RUN:return this.handleNodeRun();case f.NODE_SEND_DATA:return this.handleNodeSendData();default:r.warn(`~ NodeStatusManager: Unknown signal type: ${e}`)}}catch(e){throw r.error(`~ NodeStatusManager: Error processing signal: ${e.message}`),e}})}getQueueState(){return{queue:[...this.signalQueue],cursor:this.currentCursor}}process(){return l(this,null,function*(){for(;this.currentCursor<this.signalQueue.length;this.currentCursor++)yield this.processNextSignal();return this.status})}};var L=class p{constructor(e=[]){this.reporting=null;this.id=se(),this.output=[],this.pipelines=[],this.subPreConfigId=[],this.subPreConfig=[],this.dependencies=e,this.status=S.NODE_PENDING,this.progress=0,this.dataType=T.RAW,this.executionQueue=Promise.resolve(),this.nextNodeInfo=null,this.config=null,this.subConfig=void 0,this.statusManager=new A(this)}updateProgress(){this.progress+=1/this.pipelines.length}setConfig(e){let{chainId:t,index:o,count:n}=e||{};if(o!==void 0&&n!==void 0){let s=P.retrieveService();this.reporting=s.genReportingAgent({chainId:t,nodeId:this.id,index:o,count:n})}else r.warn("Node index is not defined, configuration failed");this.config=e,e.signalQueue&&(r.info(`Node ${this.id} enqueuing signals...`),r.debug(`${e.signalQueue}`),this.statusManager.enqueueSignals(e.signalQueue))}enqueueSignals(e,t){return l(this,null,function*(){yield this.statusManager.enqueueSignals(e,t)})}getExecutionQueue(){return this.executionQueue}getConfig(){return this.config}getId(){return this.id}addPipeline(e){this.pipelines.push(e)}processPipeline(e,t){return l(this,null,function*(){let o=t;for(let n of e)o=yield n.digest(o,this.getConfig());return o})}*getPipelineGenerator(e,t){for(let o=0;o<e.length;o+=t)yield e.slice(o,o+t)}notify(e,t="local-signal"){try{if(this.reporting!==null)typeof e=="object"&&"status"in e?this.reporting.notify(e,t):this.reporting.notify({status:e},t);else throw new Error("Reporter not set")}catch(o){r.error(o.message)}}processChildChain(e){return l(this,null,function*(){var t;if(this.subConfig=(t=this.config)==null?void 0:t.chainConfig,this.subConfig&&Array.isArray(this.subConfig)&&this.subConfig.length>0){this.subParallelConfig=this.subConfig.filter(n=>n.childMode==="parallel"),this.subParallelConfig[0].rootConfig=this.config?JSON.parse(JSON.stringify(this.config)):void 0;let o=y.retrieveService();if(this.subParallelConfig&&!(yield o.handleRequest({signal:f.CHAIN_DEPLOY,config:this.subParallelConfig,data:e})))throw new Error("Failed to deploy parallel chain: no chainId returned")}})}processPreChain(e){return l(this,null,function*(){if(this.config&&this.config.pre&&Array.isArray(this.config.pre)&&this.config.pre.length>0){let t=y.retrieveService();if(this.config.pre){for(let o of this.config.pre)if(o.length>0){let n=o.map((s,i)=>{var c,g,u,C,m;let a=(c=o[i+1])==null?void 0:c.services[0];return a||(a=(g=this.config)==null?void 0:g.services[0]),R(v({},s),{chainId:(C=(u=this.config)==null?void 0:u.chainId)!=null?C:"",nextTargetId:a?typeof a=="string"?a:a.targetId:void 0,nextNodeResolver:a?typeof a=="string"?a:(m=a.meta)==null?void 0:m.resolver:void 0,nextMeta:a&&typeof a!="string"?a.meta:void 0,targetId:s.services[0]?typeof s.services[0]=="string"?s.services[0]:s.services[0].targetId:void 0})});return yield t.broadcastNodePreSignal(n,e)}}}})}execute(e){return l(this,null,function*(){var i,a;let t=((a=(i=this.config)==null?void 0:i.rootConfig)==null?void 0:a.childMode)==="parallel"?"in parallel":"in serial",o=this.statusManager.getSuspendedState(),n=!!o;r.info(`Node ${this.id} execution ${n?"resumed":"started"} ${t}...`),this.executionQueue=this.executionQueue.then(()=>l(this,null,function*(){var d,c,g;try{if(this.config&&this.config.pre&&((c=(d=this.config)==null?void 0:d.pre)==null?void 0:c.length)>0){r.info(`child chain found in node: ${this.id}`);let m=yield this.processPreChain(e);if(e.additionalData&&e.additionalData.length>0)e.additionalData.push(m);else{let h=e;e={},e.additionalData=[],e.origin=h,e.additionalData.push((g=m==null?void 0:m.data)!=null?g:m)}}this.updateStatus(S.NODE_IN_PROGRESS);let u,C=e;if(n)this.output=[],this.output.push({data:o.data,previousNodeParams:o.previousNodeParams});else{u=this.getPipelineGenerator(this.pipelines,3);let m=u.next();for(;!m.done;)if(yield this.processBatch(m.value,C),m=u.next(),this.subPostConfig&&r.warn(`post sub config ${JSON.stringify(this.subPostConfig,null,2)}`),(yield this.statusManager.process()).includes(S.NODE_SUSPENDED)){this.statusManager.suspendExecution(u,m.value,C);return}}this.statusManager.clearSuspendedState(),this.updateStatus(S.NODE_COMPLETED),yield p.terminate(this.id,this.output)}catch(u){this.statusManager.isSuspended()||(this.statusManager.clearSuspendedState(),this.updateStatus(S.NODE_FAILED,u),r.error(`Node ${this.id} execution failed: ${u}`))}})),yield y.retrieveService().handleRequest({signal:f.NODE_SEND_DATA,id:this.id})})}processBatch(e,t){return l(this,null,function*(){return new Promise((o,n)=>{ae(()=>l(this,null,function*(){try{let s=e.map(i=>this.processPipeline(i,t).then(a=>{this.output.push(a),this.updateProgress()}));yield Promise.all(s),o()}catch(s){n(s)}}))})})}sendData(){return l(this,null,function*(){yield this.executionQueue,r.info(`Sending data from node ${this.id}.`)})}static terminate(e,t){return l(this,null,function*(){r.special(`Terminate: Node ${e} execution completed.`);let o=t[0];yield p.moveToNextNode(e,o)})}static moveToNextNode(e,t){return l(this,null,function*(){var c,g,u,C,m;let o=y.retrieveService(),s=o.getNodes().get(e),i=(c=s==null?void 0:s.getConfig())==null?void 0:c.chainId;if(!s){r.warn(`Node ${e} not found for moving to next node.`);return}let a=s.getNextNodeInfo();a?a.type===E.LOCAL?yield o.handleRequest({signal:f.NODE_RUN,id:a.id,data:t}):a.type===E.REMOTE&&o.remoteServiceCallback({chainId:i,targetId:a.id,data:t,meta:a.meta}):(r.special(`End of pipeline reached by node ${e} in chain ${i}.`),s.notify(S.NODE_END_OF_PIPELINE,"global-signal")),((u=(g=s.config)==null?void 0:g.chainType)!=null?u:0)&x.PERSISTANT?r.warn(`Node ${e} kept for future calls.`):((m=(C=s.config)==null?void 0:C.chainType)!=null?m:0)&x.AUTO_DELETE?yield o.handleRequest({id:e,signal:f.NODE_DELETE}):s.notify(S.NODE_PENDING_DELETION,"global-signal")})}getProgress(){return this.progress}canExecute(e){return this.dependencies.every(t=>e.has(t))}getDataType(){return this.dataType}getStatus(){return this.status}getDependencies(){return this.dependencies}updateStatus(e,t){this.status=e,e===S.NODE_FAILED&&(this.error=t),this.reporting&&this.reporting.notify({status:e})}getError(){return this.error}getProcessors(){return this.pipelines}setNextNodeInfo(e,t,o){this.nextNodeInfo={id:e,type:t,meta:o}}getNextNodeInfo(){return this.nextNodeInfo}};var $=class p{constructor(e){this.targetId=e.targetId,this.meta=e.meta}static setCallbackService(e){p.callbackService=e}static setPreCallbackService(e){p.preProcessorCallback=e}digest(e,t){return l(this,null,function*(){var o;return p.callbackService?(r.info(`[PipelineProcessor]: Digesting data using "${this.targetId}"`),yield p.callbackService({nextTargetId:t==null?void 0:t.nextTargetId,nextNodeResolver:t==null?void 0:t.nextNodeResolver,previousTargetId:t!=null&&t.pre&&(t==null?void 0:t.pre.length)>0&&(t!=null&&t.pre[0])&&(t==null?void 0:t.pre[0].length)>0&&(t!=null&&t.pre[0][0])&&((o=t==null?void 0:t.pre[0][0])!=null&&o.services[0])?typeof(t==null?void 0:t.pre[0][0].services[0])=="string"?t==null?void 0:t.pre[0][0].services[0]:t==null?void 0:t.pre[0][0].services[0].targetId:void 0,chainId:t==null?void 0:t.chainId,targetId:this.targetId,meta:this.meta,data:e})):{}})}};import{randomUUID as de}from"node:crypto";var y=class p{constructor(){this.uid="@supervisor:default",this.ctn="@container:default",this.nodes=new Map,this.chains=new Map,this.childChains=new Map,this.remoteServiceCallback=N.SERVICE_CALLBACK,this.broadcastSetupCallback=N.SETUP_CALLBACK,this.broadcastPreCallback=N.PRE_CALLBACK,this.nodeStatusCallback=N.NODE_STATUS_CALLBACK}static retrieveService(e=!1){if(!p.instance||e){let t=new p;p.instance=t}return p.instance}log(e){switch(e){case"chains":break;case"monitoring-workflow":{let o=P.retrieveService().getWorkflow();break}default:break}}getChain(e){return this.chains.get(e)}setNodeStatusCallback(e){this.nodeStatusCallback=e}setRemoteServiceCallback(e){this.remoteServiceCallback=e}setBroadcastSetupCallback(e){this.broadcastSetupCallback=e}setBroadcastPreCallback(e){return this.broadcastPreCallback=e,this.broadcastPreCallback}setBroadcastReportingCallback(e){P.retrieveService().setBroadcastReportingCallback(e)}setMonitoringCallback(e){P.retrieveService().setReportingCallback(e)}setUid(e){this.ctn=`@container:${e}`,this.uid=`@supervisor:${e}`}enqueueSignals(e,t,o){return l(this,null,function*(){var n;return(n=this.nodes.get(e))==null?void 0:n.enqueueSignals(t,o)})}handleRequest(e){return l(this,null,function*(){switch(e.signal){case f.NODE_SETUP:return r.event("handle NODE_SETUP"),yield this.setupNode(e.config);case f.NODE_CREATE:return r.event("handle NODE_CREATE"),yield this.createNode(e.params);case f.NODE_DELETE:return r.event("handle NODE_DELETE"),yield this.deleteNode(e.id);case f.NODE_RUN:return r.event("handle NODE_RUN"),yield this.runNode(e.id,e.data);case f.NODE_SEND_DATA:return r.event("handle NODE_SEND_DATA"),yield this.sendNodeData(e.id);case f.CHAIN_PREPARE:return r.event("handle CHAIN_PREPARE"),yield this.prepareChainDistribution(e.id);case f.CHAIN_START:return r.event("handle CHAIN_START"),yield this.startChain(e.id,e.data);case f.CHAIN_START_PENDING_OCCURRENCE:return r.event("handle CHAIN_START_PENDING_OCCURRENCE"),yield this.startPendingChain(e.id);case f.CHAIN_DEPLOY:return r.event("handle CHAIN_DEPLOY"),yield this.deployChain(e.config,e.data);default:r.warn(`${this.ctn}: Unknown signal received: ${JSON.stringify(e,null,2)}`)}})}remoteReport(e,t){P.retrieveService().genReportingAgent({chainId:t,nodeId:"supervisor-remote",index:1,count:-1}).notify(e,"global-signal")}localReport(e,t){P.retrieveService().genReportingAgent({chainId:t,nodeId:"supervisor",index:-1,count:-1}).notify({status:e},"local-signal")}deployChain(e,t,o){return l(this,null,function*(){try{if(!e)throw new Error(`${this.ctn}: Chain configuration is required`);r.info(`${this.ctn}: Starting a new chain deployment...`);let n=this.createChain(e);yield this.prepareChainDistribution(n);let s=this.chains.get(n);if(s&&(s.dataRef=t),r.info(`${this.ctn}: Deployment for chain ${n} has successfully started...`),o){let i=this.childChains.get(o)||[];i.push(n),this.childChains.set(o,i)}return this.localReport(S.CHAIN_DEPLOYED,n),n}catch(n){throw r.error(`${this.ctn}{deployChain}: ${n.message}`),n}})}createNode(e){return l(this,null,function*(){let t=new L,o=t.getId();return t.setConfig(e),this.nodes.set(o,t),r.info(`${this.ctn}: Node ${o} created with config: ${JSON.stringify(e,null,2)}`),o})}setupNode(e,t=!1){return l(this,null,function*(){this.updateChain([e]);let o=yield this.createNode(e),n=this.nodes.get(o);if(!n)return r.warn(`${this.ctn}: Attempted to setup undefined node`),o;r.header(`Setup node ${n==null?void 0:n.getId()}...`),yield this.setRemoteMonitoringHost(e);let s=e.services.map(i=>new $(typeof i=="string"?{targetId:i}:i));return yield this.addProcessors(o,s),r.info(`${this.ctn}: Node ${o} setup completed with ${s.length} processors`),e.nextTargetId!==void 0?n.setNextNodeInfo(e.nextTargetId,E.REMOTE,e.nextMeta):t||r.warn(`${this.ctn}: Cannot set next node info: nextTargetId is undefined`),this.notify(o,S.NODE_SETUP_COMPLETED,"global-signal"),o})}handleNotification(e,t){try{let o=this.chains.get(e);if(!o){r.warn(`${this.ctn}: Chain with ID ${e} not found.`);return}let n=o.rootNodeId;if(!n){r.warn(`${this.ctn}: Root node ID missing for chain ${e}.`);return}let s=this.nodes.get(n);if(!s){r.warn(`${this.ctn}: Node with ID ${n} not found.`);return}r.info(`${this.ctn}:
		Sending notification to node ${n}
		with status ${JSON.stringify(t)}.`),s.notify(t,"global-signal")}catch(o){r.error(`${this.ctn}: Failed to handle notification for chain ${e}: ${o.message}`)}}notify(e,t,o="local-signal"){let n=this.nodes.get(e);n?n.notify(t,o):r.warn(`${this.ctn}: Can't notify non-existing node ${e}`)}addProcessors(e,t){return l(this,null,function*(){let o=this.nodes.get(e);o?(o.addPipeline(t),r.info(`${this.ctn}: Processors added to Node ${e}.`)):r.warn(`${this.ctn}: Node ${e} not found.`)})}deleteNode(e){return l(this,null,function*(){this.nodes.has(e)?(this.nodes.delete(e),r.info(`${this.ctn}: Node ${e} deleted.`)):r.warn(`${this.ctn}: Node ${e} not found.`)})}createChain(e){var t;try{if(!e||!Array.isArray(e))throw new Error("Invalid chain configuration: config must be an array");let o=Date.now(),n=`${this.uid}-${o}-${de().slice(0,8)}`,s={config:e};this.chains.set(n,s);let i=e[0].rootConfig?e[0].rootConfig.monitoringHost:(t=e[0])==null?void 0:t.monitoringHost,a=Array.isArray(e)?e.length:0;return a>0?e.forEach((d,c)=>{d&&(d.index=c,d.count=a,d.monitoringHost=i)}):r.warn(`${this.ctn}: Chain configuration is empty`),r.header(`${this.ctn}:
	Chain ${n} creation has started...`),n}catch(o){throw r.header(`${this.ctn}{createChain}:
	${o.message}`),o}}updateChain(e){if(e.length===0||!e[0].chainId)throw new Error("Invalid chain configuration");let t=e[0].chainId,o=this.chains.get(t);return o?(o.config=o.config.concat(e),r.info(`${this.ctn}: Chain ${t} updated with ${e.length} new configurations`)):(o={config:e},this.chains.set(t,o),r.info(`${this.ctn}: Chain ${t} created with ${e.length} configurations`)),t}setRemoteMonitoringHost(e){return l(this,null,function*(){let t=e.monitoringHost;if(!t)throw new Error(`${this.ctn}: No Monitoring Host set for Chain ${e.chainId} during distribution`);P.retrieveService().setRemoteMonitoringHost(e.chainId,t)})}prepareChainDistribution(e){return l(this,null,function*(){try{r.header(`${this.ctn}:
	Chain distribution for ${e} in progress...`);let t=this.chains.get(e);if(!t)throw new Error(`${this.ctn}: Chain ${e} not found`);let o=t.config,n=o.filter(i=>i.location==="local"),s=o.filter(i=>i.location==="remote");if(n||r.warn("Local config undefined"),n.length>0){let i=yield this.setupNode(R(v({},n[0]),{chainId:e}),!0);t.rootNodeId=i;let a=i;for(let d=1;d<n.length;d++){let c=yield this.setupNode(R(v({},n[d]),{chainId:e}),!0),g=this.nodes.get(a);g&&g.setNextNodeInfo(c,E.LOCAL),a=c}if(s||r.warn("Remote config undefined"),s.length>0&&s[0].services.length>0){let d=this.nodes.get(a);if(d){let c=s[0].services[0];d.setNextNodeInfo(typeof c=="string"?c:c.targetId,E.REMOTE,typeof c=="string"?void 0:c.meta)}}}else r.warn(`${this.ctn}: No local config found for chain ${e}. Root node unavailable.`);try{if(s.length>0){let i=s.map((a,d)=>{var u,C;let c=(u=s[d+1])==null?void 0:u.services[0];return R(v({},a),{nextTargetId:c?typeof c=="string"?c:c.targetId:void 0,nextNodeResolver:c?typeof c=="string"?c:(C=c.meta)==null?void 0:C.resolver:void 0,nextMeta:c&&typeof c!="string"?c.meta:void 0})});yield this.broadcastNodeSetupSignal(e,i)}}catch(i){r.error(`${this.ctn}{prepareChainDistribution, broadcast}: ${i.message}`)}}catch(t){throw r.error(`${this.ctn}{prepareChainDistribution}: ${t.message}`),t}})}broadcastNodeSetupSignal(e,t){return l(this,null,function*(){let o={signal:f.NODE_SETUP,chain:{id:e,config:t}};try{yield this.broadcastSetupCallback(o),r.info(`${this.ctn}: Node creation signal broadcasted with chainId: ${e} for remote configs`)}catch(n){r.error(`${this.ctn}: Failed to broadcast node creation signal: ${n}`)}})}broadcastNodePreSignal(e,t){return l(this,null,function*(){let o={signal:f.NODE_PRE,chain:{config:e,data:t}};try{return r.info(`${this.ctn}: Node creation signal broadcasted with chainId: ${e[0].chainId} for remote configs`),yield this.broadcastPreCallback(o)}catch(n){r.error(`${this.ctn}: Failed to broadcast node creation signal: ${n}`)}})}startPendingChain(e){return l(this,null,function*(){var n,s,i;let t=this.chains.get(e),o=t==null?void 0:t.dataRef;if(o)if((n=t==null?void 0:t.config[0])==null?void 0:n.rootConfig){let d=t==null?void 0:t.rootNodeId;if(!d)throw new Error("Root node ID not found");(((i=(s=t==null?void 0:t.config[0])==null?void 0:s.rootConfig)==null?void 0:i.childMode)==="parallel"?"parallel":"serial")==="parallel"?(this.notify(d,S.CHILD_CHAIN_STARTED,"global-signal"),this.startChain(e,o).then(()=>this.notify(d,S.CHILD_CHAIN_COMPLETED,"global-signal")).catch(g=>{})):(yield this.startChain(e),this.notify(d,S.CHILD_CHAIN_COMPLETED,"global-signal"))}else yield this.startChain(e,o);else yield this.startChain(e),r.warn(`${this.ctn}:
	Nothing to process on chain ${e}`)})}startChain(e,t){return l(this,null,function*(){r.header(`<<Start Chain>>: Chain ${e} requested...`),r.info(`Data: ${JSON.stringify(t,null,2)}`);let o=this.chains.get(e);if(!o){r.warn(`Chain ${e} not found.`);return}let n=o.rootNodeId;if(!n){r.error(`${this.ctn}: Root node ID for chain ${e} not found.`);return}if(!this.nodes.get(n)){r.error(`${this.ctn}: Root node ${n} for chain ${e} not found.`);return}try{yield this.runNode(n,t),r.info(`${this.ctn}: Chain ${e} started with root node ${n}.`)}catch(i){r.error(`${this.ctn}: Failed to start chain ${e}: ${i}`)}})}runNode(e,t){return l(this,null,function*(){let o=this.nodes.get(e);o?yield o.execute(t):r.warn(`${this.ctn}: Node ${e} not found.`)})}runNodeByRelation(e){return l(this,null,function*(){try{let{targetId:t,chainId:o,data:n}=e;if(r.info(`Received data for node hosting target ${t}`),o===void 0)throw new Error("chainId is undefined");if(t===void 0)throw new Error("targetId is undefined");let s=this.getNodesByServiceAndChain(t,o);if(!s||s.length===0)throw new Error(`No node found for targetId ${t} and chainId ${o}`);let i=s[0].getId();if(i===void 0)throw new Error(`No node ID exists for targetId ${t} and chainId ${o}`);yield this.handleRequest({signal:f.NODE_RUN,id:i,data:n})}catch(t){}})}sendNodeData(e){return l(this,null,function*(){let t=this.nodes.get(e);if(t)try{yield t.sendData()}catch(o){let n=o}})}getNodes(){return this.nodes}getNodesByServiceAndChain(e,t){return Array.from(this.nodes.values()).filter(o=>{let n=o.getConfig();return n?n.chainId===t&&n.services.some(s=>typeof s=="string"?s===e:s.targetId===e):!1})}};var M;(e=>{class p{static triggerPendingOccurrence(o){return l(this,null,function*(){let n=y.retrieveService(),s={signal:f.CHAIN_START_PENDING_OCCURRENCE,id:o};yield n.handleRequest(s),r.event("MonitoringSignalHandler: Start Pending Occurrence...")})}static handle(o){return l(this,null,function*(){var a;let n=P.retrieveService(),s=(a=o.signal)==null?void 0:a.status,i=o.chainId;switch(s){case S.NODE_SETUP_COMPLETED:{let d=n.getChainSetupCount(i);d?n.setChainSetupCount(i,d+1):n.setChainSetupCount(i,1),d=n.getChainSetupCount(i),d&&d>=o.count&&(n.setChainSetupCompleted(i),r.event("MonitoringSignalHandler: Chain Nodes setup completed"),n.getChainDeployed(i)&&(yield this.triggerPendingOccurrence(i)));break}case S.CHAIN_DEPLOYED:{n.setChainDeployed(i),r.event("MonitoringSignalHandler: Chain deployed"),n.getChainSetupCompleted(i)&&(yield this.triggerPendingOccurrence(i));break}case S.CHAIN_NOTIFIED:{let{signal:d,payload:c}=o.signal,g=y.retrieveService(),u={payload:c,chainId:i,signal:d!=null?d:f.NODE_ERROR,nodeId:"",index:0,count:0};g.nodeStatusCallback(u);break}default:r.event(`MonitoringSignalHandler:
		Signal handler not found for ${JSON.stringify(o.signal)}`);break}})}}e.MonitoringSignalHandler=p})(M||(M={}));import{Buffer as ce}from"buffer";import*as pe from"http";import*as ge from"https";var b=(p,e)=>l(void 0,null,function*(){let t=p.protocol==="https:",o={hostname:p.hostname,port:p.port||(t?"443":"80"),path:p.pathname,method:"POST",headers:{"Content-Type":"application/json","Content-Length":ce.byteLength(e)}};return new Promise((n,s)=>{let i=(t?ge:pe).request(o,a=>{let d="";a.on("data",c=>{d+=c}),a.on("end",()=>{a.statusCode&&a.statusCode>=200&&a.statusCode<300?n(d):s(new Error(`HTTP Error: ${a.statusCode} ${a.statusMessage} - URL: ${o.hostname}${o.path}`))})});i.on("error",a=>{s(new Error(`Request failed to ${p.href}: ${a.message}`))}),i.write(e),i.end()})});var B;(s=>{s.reportingCallback=i=>l(void 0,null,function*(){let{message:a,reportSignalHandler:d}=i;yield d(a)});let e=i=>l(void 0,null,function*(){yield M.MonitoringSignalHandler.handle(i)});s.defaultMonitoringResolver=i=>l(void 0,null,function*(){try{let d=P.retrieveService().getRemoteMonitoringHost(i);if(d!==void 0)return r.info({message:`DRC: Resolving host for monitoring: ${d}`}),d;throw new Error("Monitoring host not found, selected chain may not exist.")}catch(a){r.error({message:a.message})}});let o=i=>l(void 0,null,function*(){try{let{message:a,path:d,monitoringResolver:c}=i,g=yield c(a.chainId),u=new URL(d,g);r.debug(u.href);let C=JSON.stringify(a);r.info(`BroadcastReportingCallback: Sending message to ${u}`),yield b(u,C)}catch(a){r.error({message:a.message})}});s.setMonitoringCallbacks=i=>l(void 0,null,function*(){let{paths:a,reportSignalHandler:d,monitoringResolver:c}=i,g=y.retrieveService();g.setMonitoringCallback(u=>l(void 0,null,function*(){let C={message:u,reportSignalHandler:d!=null?d:e};yield(0,s.reportingCallback)(C)})),d?r.info("Monitoring Callback set with custom Signal Handler"):r.info("Monitoring Callback set with default Signal Handler"),g.setBroadcastReportingCallback(u=>l(void 0,null,function*(){let C={message:u,path:a.notify,monitoringResolver:c!=null?c:s.defaultMonitoringResolver};yield o(C)})),c?r.info("Broadcast Reporting Callback set with custom Resolver"):r.info("Broadcast Reporting Callback set with default Resolver")})})(B||(B={}));var H;(s=>{s.broadcastSetupCallback=i=>l(void 0,null,function*(){let{message:a,hostResolver:d,path:c}=i;r.info(`Broadcast message: ${JSON.stringify(a,null,2)}`);let g=a.chain.config,u=a.chain.id;for(let C of g){let m=t(C,d);try{let h=JSON.stringify({chainId:u,remoteConfigs:C}),j=new URL(c,m==null?void 0:m.host);b(j,h)}catch(h){r.error(`Unexpected error sending setup request to ${m==null?void 0:m.host} for targetId ${m==null?void 0:m.targetId}: ${h.message}`)}}}),s.broadcastPreCallback=i=>l(void 0,null,function*(){let{message:a,hostResolver:d,path:c}=i,g=a.chain.config;for(let u of g){let C=t(u,d);try{let m=JSON.stringify(u),h=new URL(c,C==null?void 0:C.host);return r.info(`Broadcast pre message at url: ${JSON.stringify(h,null,2)}`),JSON.parse(yield b(h,m))}catch(m){r.error(`Unexpected error sending setup request to ${C==null?void 0:C.host} for targetId ${C==null?void 0:C.targetId}: ${m.message}`)}}});let t=(i,a)=>{if(i.services.length===0){r.warn("Empty services array encountered in config");return}let d=i.services[0],c=typeof d=="string"?d:d.targetId,g=typeof d=="string"?void 0:d.meta,u=a(c,g);if(!u){r.warn(`No container address found for targetId: ${c}`);return}return{service:d,targetId:c,meta:g,host:u}};s.remoteServiceCallback=i=>l(void 0,null,function*(){let{cbPayload:a,hostResolver:d,path:c}=i;r.info(`Service callback payload: ${JSON.stringify(i,null,2)}`);try{if(!a.chainId)throw new Error("payload.chainId is undefined");let g=d(a.targetId,a.meta);if(!g)throw new Error(`Next connector URI not found for the following target service: ${a.targetId}`);let u=new URL(c,g);r.info(`Sending data to next connector on: ${u.href}`);let C=JSON.stringify(a);yield b(u,C)}catch(g){throw r.error(`Error sending data to next connector: ${g.message}`),g}}),s.setResolverCallbacks=i=>l(void 0,null,function*(){let{paths:a,hostResolver:d}=i,c=y.retrieveService();c.setBroadcastSetupCallback(g=>l(void 0,null,function*(){let u={message:g,hostResolver:d,path:a.setup};yield(0,s.broadcastSetupCallback)(u)})),c.setBroadcastPreCallback(g=>l(void 0,null,function*(){let u={message:g,hostResolver:d,path:a.pre};return yield(0,s.broadcastPreCallback)(u)})),c.setRemoteServiceCallback(g=>l(void 0,null,function*(){let u={cbPayload:g,hostResolver:d,path:a.run};yield(0,s.remoteServiceCallback)(u)}))})})(H||(H={}));var U;(o=>{o.defaultHostResolver=n=>l(void 0,null,function*(){var s;try{let i=(s=n.payload)==null?void 0:s.hostURI;if(i)return i;throw new Error("host URI not set")}catch(i){r.error(`${i.message}`)}});let e=n=>l(void 0,null,function*(){try{let{message:s,path:i,hostResolver:a}=n,d=yield a(s),c=new URL(i,d),g=JSON.stringify(s);r.info(`NodeStatusCallback: Sending message to ${c}`),yield b(c,g)}catch(s){r.error(`${s.message}`)}});o.setNodeStatusResolverCallbacks=n=>l(void 0,null,function*(){let{paths:s,hostResolver:i}=n;y.retrieveService().setNodeStatusCallback(d=>l(void 0,null,function*(){let c={message:d,hostResolver:i!=null?i:o.defaultHostResolver,path:s.enqueue};yield e(c)}))})})(U||(U={}));var K;(n=>(n.Monitoring=M,n.Reporting=B,n.Resolver=H,n.NodeStatus=U))(K||(K={}));export{S as ChainStatus,x as ChainType,T as DataType,K as Ext,f as NodeSignal,y as NodeSupervisor,E as NodeType,$ as PipelineProcessor};
//# sourceMappingURL=index.mjs.map